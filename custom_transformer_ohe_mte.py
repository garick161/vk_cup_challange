# -*- coding: utf-8 -*-
"""custom_trans.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1O5OCfzqWe4q3Q6KGP2QXAiJPEOd37GeS
"""

from sklearn.base import BaseEstimator, TransformerMixin
import itertools
import pandas as pd
import numpy as np



class CustomTransformer(BaseEstimator, TransformerMixin):
  """ Класс для преобразования категориальных колонок с помощью OneHotEncoding и
  MeanTargetEncoding c добавлением шума
  
  Parameters
  ----------
  ohe_col: list, default=[]
      Список названий колонок, к которым будет пременен метод OneHotEncoding (OHE)
  
  mte_col: list, default=[]
      Список названий колонок, к которым будет пременен метод MeanTargetEncoding (MTE)
      
  target: str, default=None
      Название колнонки с целевой переменной
  
  Attributes
  ----------
  self.ohe_names: dict {'name_col' : 'name_col_nunique'}
      Словарь с именами колонок после преобразования OHE 
      Для чего необходимо заводить этот словарь?
      При применении трансформера мы используем метод 'fit_transform' на тренировочной части данных и
      'transform' уже для тестовой. Может так получится, что в количество уникальных значений
      признака в train и test может отличаться, следоватьно результат OHE тоже будет различным. Во избежании
      этого конфликта мы заводим словарь и именами будущих колонок на основании тренировочного набора данных.
      Если в test не хватает уникальных значений признака, искуственно добавляем эту колонку с нулями.
      Если в test присутствует уникальное значение, которое раньше в train не встречалось, убираем его.
  
   self.mte_dict: dict {'name_col' : 'mte_value'}
       Словарь с именами колонок и значениями 'mte' преобразования MTE
       Нужен для реализации концепции: train - 'fit_transform', test - 'transform'. Тем самым сохраняя
       истинное распледеление таргета среди уникальных категорий признака. Так же при вычимлении значения
       добавляется шум устранения избыточной корреляции признака с таргетом.
   
"""

  def __init__(self, ohe_col=[], mte_col=[], target=None):
        self.cat_col = ohe_col
        self.mte_col = mte_col
        self.target = target

  def fit(self, X, y=None):
        """Формирует названия колонок для OHE, записывается в словарь 'self.ohe_names'
        Вычисление значений MTE и формирования словаря  'self.mte_dict'
        
        Parameters
        ----------
        X : pd.DataFrame
        
        y : None
            Ignored.
            
        Returns
        -------
        self : object
            Fitted transformer.
        """
        X_fit = X.copy()
        self.ohe_names = {}
        for col in self.cat_col:
            self.ohe_names[col] = [f'{col}_{value}' for value in np.sort(X_fit[col].dropna().unique())]

        self.mte_dict = {}
        for col in self.mte_col:
            mte = X_fit.groupby(col)[self.target].mean() + 0.006 * np.random.normal(loc=0.0, scale=1.0)
            self.mte_dict[col] = mte

        return self

  def transform(self, X, y=None):
    """ Применение OHE и MTE к датафрейму
    
        Parameters
        ----------
        X : pd.DataFrame
        
        y : None
            Ignored.
            
        Returns
        -------
        X_ : pd.DataFrame
            Transformed dataframe.
    """
    X_ = X.copy()

    # Получим результат OHE для категориальных колонок
    data_part = pd.get_dummies(X_[self.cat_col].astype(object), prefix=self.cat_col)

    # выделим название колонок получившегося датафрема, для сравнения с назаваниями в self.ohe_names
    # лишнии нужно будеет удалить, недостающие добавить, заполнить нулями
    data_part_name = data_part.columns
    all_ohe = list(itertools.chain(*list(self.ohe_names.values())))

    # соберем результат OHE в исходный датафрейм и удалим исходные колонки
    X_ = pd.concat((X_.drop(self.cat_col, axis=1), data_part), axis=1)

    # Проанализируем, полявились ли у нас лишние/недостающие колонки
    missing_columns = [x for x in all_ohe if x not in X_.columns and x not in self.mte_col]
    extra_columns = [x for x in data_part_name if x not in all_ohe]

    # Удалим лишние колонки
    X_ = X_.drop(extra_columns, axis=1)

    # Заполним недостающие нулями
    if len(missing_columns) != 0:
        zeros = np.zeros((X_.shape[0], len(missing_columns)))
        zeros = pd.DataFrame(zeros, columns=missing_columns, index=X_.index)
        X_ = pd.concat((X_, zeros), axis=1)

    # Выделим колонки, которые дают мультиколлинив=арность после OHE
    multicoll_columns = [self.ohe_names[elem][0] for elem in self.ohe_names.keys()]

    # Удалим эти колонки из конечного датафрейма
    X_.drop(multicoll_columns, axis=1, inplace=True)

    # заменим колнки для mte посчитанным значением из mte_list
    for col in self.mte_col:
        X_[col] = X_[col].map(self.mte_dict[col])
        X_[col] = X_[col].fillna(0)

    return X_
